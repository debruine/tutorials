[
["index.html", "Tutorials Overview", " Tutorials Lisa DeBruine 2019-03-28 Overview I'm slowly moving my code tutorials here. "],
["packages.html", "Chapter 1 R package with unit tests 1.1 Learning objectives 1.2 Setting up 1.3 Create your R package 1.4 Creating a function 1.5 Build your package 1.6 Error checking 1.7 Unit tests 1.8 Share your package 1.9 Further resources 1.10 Glossary", " Chapter 1 R package with unit tests 1.1 Learning objectives Create an R package Create a function Document the function Include error checking in the function Write unit tests for the function Use your package in a script Share your package through GitHub 1.2 Setting up You will need to install the following packages: install.packages(c(&quot;devtools&quot;, &quot;roxygen2&quot;, &quot;testthat&quot;, &quot;usethis&quot;, &quot;knitr&quot;)) 1.3 Create your R package Use the following command to create the framework for a new package called demopckg. Set the argment to the path where you want to save your package. The last section of the path should be the name of the package. usethis::create_package(&quot;~/rstuff/demopckg&quot;) Package names can only be letters, numbers, and full stops. You'll see the following output, and a new RStudio project will open up. You can close the old window now and just work in this project. ✔ Setting active project to &#39;~/rstuff/demopckg&#39; ✔ Creating &#39;R/&#39; ✔ Creating &#39;man/&#39; ✔ Writing &#39;DESCRIPTION&#39; ✔ Writing &#39;NAMESPACE&#39; ✔ Writing &#39;demopckg.Rproj&#39; ✔ Adding &#39;.Rproj.user&#39; to &#39;.gitignore&#39; ✔ Adding &#39;^demopckg\\\\.Rproj$&#39;, &#39;^\\\\.Rproj\\\\.user$&#39; to &#39;.Rbuildignore&#39; ✔ Opening new project &#39;demopckg&#39; in RStudio 1.3.1 Edit the DESCRIPTION file Open the DESCRIPTION file. It should look like this: Package: demopckg Title: What the Package Does (One Line, Title Case) Version: 0.0.0.9000 Authors@R: person(given = &quot;First&quot;, family = &quot;Last&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;), email = &quot;first.last@example.com&quot;) Description: What the package does (one paragraph). License: What license it uses Encoding: UTF-8 LazyData: true Change the title, authors, and description to your own information. 1.3.2 Create a LICENSE Add a license using one of the following options: usethis::use_mit_license(name = &quot;YOUR NAME&quot;) # permissive sharing usethis::use_cc0_license(name = &quot;YOUR NAME&quot;) # public domain - use for data packages usethis::use_gpl3_license(name = &quot;YOUR NAME&quot;) # derivatives must be open 1.3.3 Create a README Use the following code to set up a README document that will explain your package. usethis::use_readme_rmd() We'll eventually put this on github, so change the installation instructions to the following (change yourusername to your github username). You can install the released version of demopckg from [GitHub](https://github.com) with: &#96;&#96;&#96; r devtools::install_github(\"yourusername/demopckg\") &#96;&#96;&#96; Delete the example for now. Make sure you knit your README.Rmd file when you update it and never edit the README.md file (that's just for github). 1.4 Creating a function Function definitions are saved in the R folder. You don't have to, but I like to save each function in its own file and name the file after the function. 1.4.1 Template function Create a new R script from the File menu (New File &gt; R Script). Paste the following template into your file: #&#39; My function #&#39; #&#39; `myfunction` does something. #&#39; #&#39; @param arg1 A value to return #&#39; @return Returns the value of \\code{arg1} #&#39; @examples #&#39; #&#39; myfunction(1) # returns 1 #&#39; #&#39; @export myfunction &lt;- function(arg1 = &quot;Change me&quot;) { arg1 } 1.4.2 Edit the function We're going to create a function that reports a p-value in APA style, named report_p. It will take two arguments, the p-value (p) and the number of digits to round to (digits). Replace myfunction with report_p and change the arguments. Should p have a default value? Should digits? The first thing we should do in the function is check whether p is less than 0.001, and if it is, return the value &quot;p &lt; .001&quot;. report_p &lt;- function(p, digits = 3) { if (p &lt; .001) return(&quot;p &lt; .001&quot;) } Once you run the return() function, your function stops running. If p is greater than 0.001, then we should round it to the specified number of digits, paste it after the string &quot;p = &quot;, and return it. report_p &lt;- function(p, digits = 3) { if (p &lt; .001) return(&quot;p &lt; .001&quot;) p_round &lt;- round(p, digits) p_string &lt;- paste(&quot;p =&quot;, p_round) return(p_string) } Run your function and test it with a few different p-values and digits. Try report_p(0.01034). Does this look exactly like you expect? APA style omits the leading zero and pads the number out to three digits. We can do this by converting our rounded p-value into a character string, replacing the string &quot;0.&quot; with &quot;.&quot;, and making sure to pad the right side with enough zeros. The stringr package has useful functions for this. When you use R functions from a package (not base R), you normally load the package using the library() function. When you're developing your own package, you need to preface every function with its package name and two colons instead, so in the code below we'll use stringr::str_replace() and stringr::str_pad(), not str_replace() and str_pad(). One function you can't preface with the package name is the pipe. While you're testing your function, load the pipe by typing library(magrittr) in the console. report_p &lt;- function(p, digits = 3) { if (p &lt; .001) return(&quot;p &lt; .001&quot;) p_round &lt;- round(p, digits) %&gt;% as.character() %&gt;% # omit leading zero for APA-style stringr::str_replace(&quot;0.&quot;, &quot;.&quot;) %&gt;% # pad right with zeros stringr::str_pad(digits+1, &quot;right&quot;, 0) p_string &lt;- paste(&quot;p =&quot;, p_round) return(p_string) } 1.4.3 Documentation Now edit the commented part before your function. The #' is special to roxygen2 documentation, which we'll enable below. This generates what you see in the Help viewer. Type ?mean into the console pane and have a look at the Help pane. The first line is the name of the function in title case The Description is the lines between the title and first @param The Useage is automatically generated The Arguments section is generated from the list of @paramargument Argument description... The Value section is the text after @return The Examples section is the text under @examples This block should end with @export to make sure your function is added to your package Edit the documentation for your report_p function. Save your file in the R directory with the name report_p.R. For now, we'll make a separate file for each function and give it the name of the function. Roxygen creates automatic documentation. You enable it with the following command (you only need to run this once per package). usethis::use_roxygen_md() Now you can automatically update the documentation for your package by running devtools::document(), after which you should see the following text. Updating demopckg documentation Writing NAMESPACE Loading demopckg Writing report_p.Rd You don't need to worry about these files, they'll be added to your package to show Help documentation. 1.4.4 Imports You need to &quot;import&quot; any packages you used in your function by running usethis::use_package for each package you want to include. usethis::use_package(&quot;stringr&quot;) You can't import the whole tidyverse, but you can import each package separately (i.e., ggplot2, purrr, tibble, dplyr, tidyr, stringr, readr, forcats). Import just the packages you actually need. If you use pipes (even if you've imported dplyr), you also need to run usethis::use_pipe(). It will add a file called utils-pipe.R to your R directory and add magrittr to your Imports. 1.5 Build your package Now you're ready to check and build your package for installation. 1.5.1 Check First, check everything by running devtools::check(). You'll get a lot of output, but don't worry unless you have an error message. Hopefully, you'll get this message: 0 errors ✔ | 0 warnings ✔ | 0 notes ✔ 1.5.2 Build Next, run devtools::build(). You'll get a message that looks like this: ✔ checking for file ‘/Users/lisad/rproj/demopckg/DESCRIPTION’ ... ─ preparing ‘demopckg’: ✔ checking DESCRIPTION meta-information ... ─ checking for LF line-endings in source and make files and shell scripts ─ checking for empty or unneeded directories ─ building ‘demopckg_0.0.0.9000.tar.gz’ [1] &quot;/Users/lisad/rproj/demopckg_0.0.0.9000.tar.gz&quot; 1.5.3 Install Next, install your new package with the following code (../ means to go up one directory to look for the demopckg install file). devtools::install(&quot;../demopckg&quot;) You'll see a bunch of output that should end in: * DONE (demopckg) 1.5.4 Test To make sure it's all gone well, restart R and try to use the function report_p(0.00039). You should get an error message. Then load your new package with library(demopckg) are retry the example above. Type ?report_p in the console and look at your Help documentation. Restart R and open a new .R or .Rmd file. Load your new package at the top of the file and try using your function in a paragraph that reports the p-value for a test. 1.6 Error checking Try running your function with different values for p. What happens if you use invalid values, like 1.07, -0.05, or &quot;A&quot;? We can add error checking to a function to quit and give a message if the error is fatal, or just warn them if the error is recoverable, but probably wrong. P-values can't ever be less than 0 or greater than 1, so we can just quit and give an error message if that happens. Add the following code to the beginning of your function, rerun the code to update the function, and test it on some values of p that are less than 0 or greater than 1. if (p &lt; 0) stop(&quot;p cannot be less than 0&quot;) if (p &gt; 1) stop(&quot;p cannot be greater than 1&quot;) What other errors do you think people might make? You can add checks to the beginning of your function to warn people if they don't enter reasonable numbers for the digits argument and set digits to the default value so that the code can continue. if (!(digits %in% 1:5)) { warning(&quot;digits should probably be an integer between 1 and 5&quot;) digits = 3 } 1.7 Unit tests Up until now, we've just tested our function in an ad hoc way every time we made changes. We can make this process more formal by using unit tests. These will make sure that your function is working properly if you make any changes. This seems like overkill for simple functions, but is absolutely essential for big projects, so best to get into good habits now. 1.7.1 Setup When you set up a new package, you need to set up the testing structure using usethis::use_testthat(). You only need to do this once for each package and you will know it has been done if a new directory called tests is made. 1.7.2 New unit tests Create a new test file for the report_p function using usethis::use_test(&quot;report_p&quot;). It will create a new file called test-report_p.R in the tests/testhat/ directory. Replace the text in that file with the text below. context(&quot;report_p&quot;) testthat::test_that(&quot;errors&quot;, { testthat::expect_error( report_p(-1), &quot;p cannot be less than 0&quot; ) testthat::expect_error( report_p(2), &quot;p cannot be greater than 1&quot; ) }) The context function lets you know what function you're testing when you run all the unit tests in a package. The test_that function checks a groups of expectataions. The first set we're going to make checks if we get the error messages we expect, so we've called it &quot;errors&quot;. We're going to check two expectations, that we'll get the error message &quot;p cannot be less than 0&quot; if p = -1, and that we'll get the error message &quot;p cannot be greater than 1&quot; id p = 2. You can test more values than these, but we'll start with just these two. After you save this file, run devtools::test(). You should see output like: Loading demopckg Testing demopckg ✔ | OK F W S | Context ✔ | 2 | report_p ══ Results ═══════════════════════════════════════════════════════════ OK: 2 Failed: 0 Warnings: 0 Skipped: 0 Now add another testthat::test_that block called &quot;default values&quot;. Use the function testthat::expect_equal to check if the output of the report_p() function with different p values and the default digits value gives you the expected output. For example: testthat::expect_equal( report_p(p = 0.0222), &quot;p = .022&quot; ) 1.7.3 Run all tests Run devtools::test() after you add each test to make sure your tests work as expected. 1.8 Share your package You can do package development without a GitHub account, but this is one of the easiest ways to share your package. 1.8.1 Git on RStudio If you don't have git installed on your computer, don't have it integrated with RStudio, and/or don't have a github account, follow the instructions in Appendix @ref(#git). 1.8.2 Set up git for this project If you aren't already using version control for this project, make sure all of your files are saved and type usethis::use_git() into the console. Choose Yes to commit and Yes to restart R. 1.8.3 GitHub access token Now set up a github access token with usethis::browse_github_pat(). Your web browser will open and you'll be asked to log into your github account and then asked to authorise a new token. Accept the defaults and click OK at the bottom of the page. Figure 1.1: Authorise a github token so you can create new github repositories from RStudio Copy your token (the blacked-out bit in the image below). Figure 1.2: Copy your github token Type usethis::edit_r_environ() in the RStudio console pane. A new file called .Renviron will appear in the source pane. Add the following line to it (replace &lt;YOUR-TOKEN&gt; with your copied token). GITHUB_PAT=&lt;YOUR-TOKEN&gt; Save and close the file, then restart R. 1.8.4 Make a new GitHub repository Type usethis::use_github(protocol=&quot;https&quot;) into the console window and check that the suggested title and description are OK. ✔ Setting active project to &#39;/Users/lisad/rproj/demopckg&#39; ● Check title and description Name: demopckg Description: Demo Stuff Are title and description ok? 1: No way 2: Yeah 3: No If you choose Yeah, you'll see some messages and your web browser will open the github repsitory page. Figure 1.3: Your new github repository 1.8.5 Install your package from GitHub Install your package using the following code (replacing debruine with your github username). devtools::install_github(&quot;debruine/demopckg&quot;) 1.9 Further resources There is a lot more to learn about package development, including writing vignettes to help users understand your functions and getting your package ready to submit to CRAN. R Packages by Hadley Wickham usethis Workflow for package development by Emil Hvitfeldt 1.9.1 Workflow The following script has all of the functions you'll need to start a new package. pckg &lt;- &quot;mynewpackage&quot; pckgdir &lt;- &quot;~/rproj/&quot; me &lt;- &quot;Lisa DeBruine&quot; # run once at start of package usethis::create_package(paste0(pckgdir, pckg)) usethis::use_mit_license(name = me) usethis::use_readme_rmd() usethis::use_testthat() usethis::use_roxygen_md() usethis::use_pipe() # everyone needs pipes # code for new functions funcname &lt;- &quot;newfunction&quot; imports &lt;- c(&quot;dplyr&quot;, &quot;tidyr&quot;) usethis::edit_file(paste0(&quot;R/&quot;, funcname, &quot;.R&quot;)) usethis::use_test(funcname) for (import in imports) usethis::use_package(import) # building the package devtools::check() # can take a long time devtools::build() devtools::install(paste0(&quot;../&quot;, pckg)) # use these for specific tasks # if check takes too long devtools::document() devtools::test() devtools::run_examples() 1.9.2 The full report_p function Here's what the full function should look like. #&#39; Report p-value #&#39; #&#39; `report_p` reports a p-value. #&#39; #&#39; @param p The p-value #&#39; @param digits The number of digits to round to (default = 3) #&#39; #&#39; @return A string with the format &quot;p = .040&quot; or &quot;p &lt; .001&quot; #&#39; @examples #&#39; #&#39; report_p(0.02018) # returns &quot;p = .020&quot; #&#39; report_p(0.00028) # returns &quot;p &lt; .001&quot; #&#39; #&#39; @export report_p &lt;- function(p, digits = 3) { if (p &lt; 0) stop(&quot;p cannot be less than 0&quot;) if (p &gt; 1) stop(&quot;p cannot be greater than 1&quot;) if (digits &lt; 1) { warning(&quot;digits should probably be an integer between 1 and 5&quot;) digits = 3 } if (p &lt; .001) return(&quot;p &lt; .001&quot;) p_round &lt;- round(p, digits) %&gt;% as.character() %&gt;% # omit leading zero for APA-style stringr::str_replace(&quot;0.&quot;, &quot;.&quot;) %&gt;% # pad right with zeros stringr::str_pad(digits+1, &quot;right&quot;, 0) p_string &lt;- paste(&quot;p =&quot;, p_round) return(p_string) } 1.10 Glossary term definition argument A variable that provides input to a function. character A data type representing strings of text. function A named section of code that can be reused. git One type of version control software. github A cloud-based service for storing and sharing your version controlled files. package A group of R functions. project A way to organise related files in RStudio version control A way to save a record of changes to your files. "],
["sim-lmer.html", "Chapter 2 Simulating Mixed Effects 2.1 Setup 2.2 Random intercepts 2.3 Calculate DV 2.4 Analysis 2.5 Function 2.6 Random slopes 2.7 Calculate DV 2.8 Analysis 2.9 Function", " Chapter 2 Simulating Mixed Effects I'm going to walk through one example of simulating a dataset with random effects. I'll generate data for a Stroop task where people (subjects) say the colour of colour words (stimuli) shown in each of two versions (congruent and incongruent). Subjects are in one of two conditions (hard and easy). The dependent variable (DV) is reaction time. congruent: RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE incongruent: RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE We expect people to have faster reaction times for congruent stimuli than incongruent stimuli (main effect of version) and to be faster in the easy condition than the hard condition (main effect of condition). We'll look at some different interaction patterns below. 2.1 Setup We'll use the tidyverse to manipulate data frames and lmerTest (which includes lmer) to run the mixed effects models. I also like to set the scipen and digits options to get rid of scientific notation in lmer output. When you're simulating data, you should start your script by setting a seed. You can use any number you like, this just makes sure that you get the same results every time you run the script. (Thanks for reminding me to add and explain this, Tim Morris!) library(tidyverse) # for data wrangling, pipes, and good dataviz library(lmerTest) # for mixed effect models library(GGally) # makes it easy to plot relationships between variables # devtools::install_github(&quot;debruine/faux&quot;) library(faux) # for simulating correlated variables options(&quot;scipen&quot;=10, &quot;digits&quot;=4) # control scientific notation set.seed(8675309) # Jenny, I&#39;ve got your number If you are running repeated simulations (e.g., for a power calculation), make sure you never use set.seed inside of a function that creates random numbers, or the function will always give you the exact same numbers. 2.2 Random intercepts 2.2.1 Subjects First, we need to generate a sample of subjects. Each subject will have slightly faster or slower reaction times on average; this is their random intercept (sub_i). We'll model it from a normal distribution with a mean of 0 and SD of 100ms. We also add between-subject variables here. Each subject is in only one condition, so assign half easy and half hard. Set the number of subjects as sub_n at the beginning so you can change this in the future with only one edit. sub_n &lt;- 200 # number of subjects in this simulation sub_sd &lt;- 100 # SD for the subjects&#39; random intercept sub &lt;- tibble( sub_id = 1:sub_n, sub_i = rnorm(sub_n, 0, sub_sd), # random intercept sub_cond = rep(c(&quot;easy&quot;,&quot;hard&quot;), each = sub_n/2) # between-subjects factor ) If you already have pilot data, you can estimate a realistic SD for the subjects' random intercepts using the following code. pilot_data &lt;- read_csv(&quot;pilot_data.csv&quot;) pilot_mod &lt;- lmer(dv ~ 1 + (1 | sub_id) + (1 | stim_id), data = pilot_data) sub_sd &lt;- VarCorr(pilot_mod) %&gt;% as.data.frame() %&gt;% filter(grp == &quot;sub_id&quot;) %&gt;% pull(sdcor) I like to check my simulations at every step with a graph. We expect subjects in hard and easy conditions to have approximately equal intercepts. ggplot(sub, aes(sub_i, color = sub_cond)) + geom_density() Figure 2.1: Double-check subject intercepts 2.2.2 Stimuli Now, we generate a sample of stimuli. Each stimulus will have slightly faster or slower reaction times on average; this is their random intercept (stim_i). We'll model it from a normal distribution with a mean of 0 and SD of 50ms (it seems reasonable to expect less variability between words than people for this task). Stimulus version (congruent vs incongruent) is a within-stimulus variable, so we don't need to add it here. stim_n &lt;- 50 # number of stimuli in this simulation stim_sd &lt;- 50 # SD for the stimuli&#39;s random intercept stim &lt;- tibble( stim_id = 1:stim_n, stim_i = rnorm(stim_n, 0, stim_sd) # random intercept ) If you want to simulate data using the exact stimuli you already have pilot data for, you can calculate their random intercepts using the following code and use that instead of generating a random sample with the same SD. pilot_data &lt;- read_csv(&quot;pilot_data.csv&quot;) pilot_mod &lt;- lmer(dv ~ 1 + (1 | sub_id) + (1 | stim_id), data = pilot_data) stim &lt;- ranef(pilot_mod)$stim_id %&gt;% as_tibble(rownames = &#39;stim_id&#39;) %&gt;% rename(stim_i = `(Intercept)`) Plot the random intercepts to double-check they look like you expect. ggplot(stim, aes(stim_i)) + geom_density() Figure 2.2: Double-check stimulus intercepts 2.2.3 Trials Now we put the subjects and stimuli together. In this study, all subjects respond to all stimuli in both upright and inverted versions, but subjects are in only one condition. The function expand.grid gives you a data frame with all possible combinations of the arguments. Add the data specific to each subject and stimulus by left joining the sub and stim data frames. trials &lt;- expand.grid( sub_id = sub$sub_id, # get subject IDs from the sub data table stim_id = stim$stim_id, # get stimulus IDs from the stim data table stim_version = c(&quot;congruent&quot;, &quot;incongruent&quot;) # all subjects see both congruent and incongruent versions of all stimuli ) %&gt;% left_join(sub, by = &quot;sub_id&quot;) %&gt;% # includes the intercept and conditin for each subject left_join(stim, by = &quot;stim_id&quot;) # includes the intercept for each stimulus Table 2.1: Subject- and stimulus-specific random intercepts for 2 subjects and 2 stimuli sub_id stim_id stim_version sub_i sub_cond stim_i 1 1 congruent -99.66 easy -4.418 2 1 congruent 72.18 easy -4.418 1 2 congruent -99.66 easy 4.057 2 2 congruent 72.18 easy 4.057 1 1 incongruent -99.66 easy -4.418 2 1 incongruent 72.18 easy -4.418 1 2 incongruent -99.66 easy 4.057 2 2 incongruent 72.18 easy 4.057 2.3 Calculate DV Now we can calculate the DV by adding together an overall intercept (mean RT for all trials), the subject-specific intercept, the stimulus-specific intercept, the effect of subject condition, the interaction between condition and version (set to 0 for this first example), the effect of stimulus version, and an error term. 2.3.1 Fixed effects We set these effects in raw units (ms) and effect-code the subject condition and stimulus version. It's usually easiest to interpret if you recode the level that you predict will be larger as +0.5 and the level you predict will be smaller as -0.5. So when we set the effect of subject condition (sub_cond_eff) to 50, that means the average difference between the easy and hard condition is 50ms. Easy is effect-coded as -0.5 and hard is effect-coded as +0.5, which means that trials in the easy condition have -0.5 * 50ms (i.e., -25ms) added to their reaction time, while trials in the hard condition have +0.5 * 50ms (i.e., +25ms) added to their reaction time. # set variables to use in calculations below grand_i &lt;- 400 # overall mean DV sub_cond_eff &lt;- 50 # mean difference between conditions: hard - easy stim_version_eff &lt;- 50 # mean difference between versions: incongruent - congruent cond_version_ixn &lt;- 0 # interaction between version and condition error_sd &lt;- 25 # residual (error) SD We set the error SD fairly low here so that it's easier to see how the parameters we set map onto the analysis output. You can calculate a realistic error SD from pilot data with the code below. pilot_data &lt;- read_csv(&quot;pilot_data.csv&quot;) pilot_mod &lt;- lmer(dv ~ 1 + (1 | sub_id) + (1 | stim_id), data = pilot_data) error_sd &lt;- VarCorr(pilot_mod) %&gt;% as.data.frame() %&gt;% filter(grp == &quot;Residual&quot;) %&gt;% pull(sdcor) The code chunk below effect-codes the condition and version factors (important for the analysis below), generates an error term for each trial, and generates the DV. dat &lt;- trials %&gt;% mutate( # effect-code subject condition and stimulus version sub_cond.e = recode(sub_cond, &quot;hard&quot; = -0.5, &quot;easy&quot; = +0.5), stim_version.e = recode(stim_version, &quot;congruent&quot; = -0.5, &quot;incongruent&quot; = +0.5), # calculate error term (normally distributed residual with SD set above) err = rnorm(nrow(.), 0, error_sd), # calculate DV from intercepts, effects, and error dv = grand_i + sub_i + stim_i + err + (sub_cond.e * sub_cond_eff) + (stim_version.e * stim_version_eff) + (sub_cond.e * stim_version.e * cond_version_ixn) # in this example, this is always 0 and could be omitted ) As always, graph to make sure you've simulated the general pattern you expected. ggplot(dat, aes(sub_cond, dv, color = stim_version)) + geom_hline(yintercept = grand_i) + geom_violin(alpha = 0.5) + geom_boxplot(width = 0.2, position = position_dodge(width = 0.9)) Figure 2.3: Double-check the simulated pattern Let's take a concrete example. Table 2.2: Subject 1's reaction time to stimulus 1 in the congruent condition sub_id stim_id stim_version sub_i sub_cond stim_i sub_cond.e stim_version.e err dv 1 1 congruent -99.66 easy -4.418 0.5 -0.5 -8.318 287.6 The DV is equal to the grand intercept (400) plus the subject's intercept (-99.6582) plus the stimulus' intercept (-4.4182) plus the effect code for the subject's condition (easy = -0.5) times the effect size for subject condition (50) plus the effect code for stimulus version (congruent = -0.5) times the effect size for stimulus version (50) plus some random error (-8.3181). 400 + -99.6582 + -4.4182 + (-0.5 * 50) + (-0.5 * 50) + -8.3181 = 287.6054 In this simulated dataset, the grand intercept is 401.6, the mean difference between subject conditions is 60.2, and the mean difference between stimulus versions is -49.5. 2.3.2 Interactions If you want to simulate an interaction, it can be tricky to figure out what to set the main effects and interaction effect to. It can be easier to think about the simple main effects for each cell. Create four new variables and set them to the deviations from the overall mean you'd expect for each condition (so they should add up to 0). Here, we're simulating a small effect of version in the hard condition (50ms difference) and double that effect of version in the easy condition (100ms difference). # set variables to use in calculations below grand_i &lt;- 400 hard_congr &lt;- -25 hard_incon &lt;- +25 easy_congr &lt;- -50 easy_incon &lt;- +50 error_sd &lt;- 25 Use the code below to transform the simple main effects above into main effects and interactions for use in the equations below. # calculate main effects and interactions from simple effects above # mean difference between easy and hard conditions sub_cond_eff &lt;- (easy_congr + easy_incon)/2 - (hard_congr + hard_incon)/2 # mean difference between incongruent and congruent versions stim_version_eff &lt;- (hard_incon + easy_incon)/2 - (hard_congr + easy_congr)/2 # interaction between version and condition cond_version_ixn &lt;- (easy_incon - easy_congr) - (hard_incon - hard_congr) Then generate the DV the same way we did above, but also add the interaction effect multiplied by the effect-coded subject condition and stimulus version. dat &lt;- trials %&gt;% mutate( # effect-code subject condition and stimulus version sub_cond.e = recode(sub_cond, &quot;hard&quot; = -0.5, &quot;easy&quot; = +0.5), stim_version.e = recode(stim_version, &quot;congruent&quot; = -0.5, &quot;incongruent&quot; = +0.5), # calculate error term (normally distributed residual with SD set above) err = rnorm(nrow(.), 0, error_sd), # calculate DV from intercepts, effects, and error dv = grand_i + sub_i + stim_i + err + (sub_cond.e * sub_cond_eff) + (stim_version.e * stim_version_eff) + (sub_cond.e * stim_version.e * cond_version_ixn) ) ggplot(dat, aes(sub_cond, dv, color = stim_version)) + geom_hline(yintercept = grand_i) + geom_violin(alpha = 0.5) + geom_boxplot(width = 0.2, position = position_dodge(width = 0.9)) Figure 2.4: Double-check the interaction between condition and version Let's look at subject 1's reaction time to stimulus 1 in the congruent condition in more detail again. Table 2.3: Subject 1's reaction time to stimulus 1 in the congruent condition sub_id stim_id stim_version sub_i sub_cond stim_i sub_cond.e stim_version.e err dv 1 1 congruent -99.66 easy -4.418 0.5 -0.5 -31.74 214.2 The DV is equal to the grand intercept (400) plus the subject's intercept (-99.6582) plus the stimulus' intercept (-4.4182) plus the effect code for the subject's condition (easy = -0.5) times the effect size for subject condition (0) plus the effect code for stimulus version (congruent = -0.5) times the effect size for stimulus version(75) plus the effect code for the subject's condition (easy = -0.5) times the effect code for stimulus version (congruent = -0.5) times the effect size for the interaction (50) plus some random error (-31.7369). 400 + -99.6582 + -4.4182 + (-0.5 * 0) + (-0.5 * 75) + (-0.5 * -0.5 * 50) + -31.7369 = 214.1866 group_by(dat, sub_cond, stim_version) %&gt;% summarise(m = mean(dv) - grand_i %&gt;% round(1)) %&gt;% ungroup() %&gt;% spread(stim_version, m) %&gt;% knitr::kable() sub_cond congruent incongruent easy -42.54 57.56 hard -28.16 20.89 2.4 Analysis New we will run a linear mixed effects model with lmer and look at the summary. mod &lt;- lmer(dv ~ sub_cond.e * stim_version.e + (1 | sub_id) + (1 | stim_id), data = dat) mod.sum &lt;- summary(mod) mod.sum ## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [ ## lmerModLmerTest] ## Formula: dv ~ sub_cond.e * stim_version.e + (1 | sub_id) + (1 | stim_id) ## Data: dat ## ## REML criterion at convergence: 187441 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -3.777 -0.664 -0.001 0.661 3.617 ## ## Random effects: ## Groups Name Variance Std.Dev. ## sub_id (Intercept) 9180 95.8 ## stim_id (Intercept) 3070 55.4 ## Residual 629 25.1 ## Number of obs: 20000, groups: sub_id, 200; stim_id, 50 ## ## Fixed effects: ## Estimate Std. Error df t value Pr(&gt;|t|) ## (Intercept) 401.937 10.360 131.411 38.80 &lt;2e-16 ## sub_cond.e 11.146 13.555 198.000 0.82 0.41 ## stim_version.e 74.574 0.355 19749.000 210.31 &lt;2e-16 ## sub_cond.e:stim_version.e 51.053 0.709 19749.000 71.99 &lt;2e-16 ## ## (Intercept) *** ## sub_cond.e ## stim_version.e *** ## sub_cond.e:stim_version.e *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Correlation of Fixed Effects: ## (Intr) sb_cn. stm_v. ## sub_cond.e 0.000 ## stim_versn. 0.000 0.000 ## sb_cnd.:s_. 0.000 0.000 0.000 2.4.1 Sense checks First, check that your groups make sense (mod.sum$ngrps). The number of obs should be the total number of trials analysed. sub_id should be what we set sub_n to above (200). stim_id should be what we set stim_n to above (50). ## sub_id stim_id ## 200 50 Next, look at the random effects (mod.sum$varcor). The SD for sub_id should be near the sub_sd of 100. The SD for stim_id should be near the stim_sd off 50. The residual SD should be near the error_sd of 25. ## Groups Name Std.Dev. ## sub_id (Intercept) 95.8 ## stim_id (Intercept) 55.4 ## Residual 25.1 Finally, look at the fixed effects (mod.sum$coefficients). The estimate for the Intercept should be near the grand_i of 400. The main effect of sub_cond.e should be near what we calculated for sub_cond_eff (0). The main effect of stim_version.e should be near what we calculated for stim_version_eff (75) The interaction between sub_cond.e:stim_version.e should be near what we calculated for cond_version_ixn (50). ## Estimate Std. Error df t value Pr(&gt;|t|) ## (Intercept) 401.94 10.3598 131.4 38.7979 7.766e-74 ## sub_cond.e 11.15 13.5547 198.0 0.8223 4.119e-01 ## stim_version.e 74.57 0.3546 19749.0 210.3088 0.000e+00 ## sub_cond.e:stim_version.e 51.05 0.7092 19749.0 71.9876 0.000e+00 2.4.2 Random effects Plot the subject intercepts from our code above (sub$sub_i) against the subject intercepts calculcated by lmer (ranef(mod)$sub_id). ranef(mod)$sub_id %&gt;% as_tibble(rownames = &quot;sub_id&quot;) %&gt;% rename(mod_sub_i = `(Intercept)`) %&gt;% mutate(sub_id = as.integer(sub_id)) %&gt;% left_join(sub, by = &quot;sub_id&quot;) %&gt;% ggplot(aes(sub_i,mod_sub_i)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + xlab(&quot;Simulated random intercepts (sub_i)&quot;) + ylab(&quot;Modeled random intercepts&quot;) Figure 2.5: Compare simulated subject random intercepts to those from the model Plot the stimulus intercepts from our code above (stim$stim_i) against the stimulus intercepts calculcated by lmer (ranef(mod)$stim_id). ranef(mod)$stim_id %&gt;% as_tibble(rownames = &quot;stim_id&quot;) %&gt;% rename(mod_stim_i = `(Intercept)`) %&gt;% mutate(stim_id = as.integer(stim_id)) %&gt;% left_join(stim, by = &quot;stim_id&quot;) %&gt;% ggplot(aes(stim_i,mod_stim_i)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + xlab(&quot;Simulated random intercepts (stim_i)&quot;) + ylab(&quot;Modeled random intercepts&quot;) Figure 2.6: Compare simulated stimulus random intercepts to those from the model 2.5 Function You can put the code above in a function so you can run it more easily and change the parameters. I removed the plot and set the argument defaults to the same as the example above, but you can set them to other patterns. sim_lmer &lt;- function( sub_n = 200, sub_sd = 100, stim_n = 50, stim_sd = 50, grand_i = 400, hard_congr = -25, hard_incon = +25, easy_congr = -50, easy_incon = +50, error_sd = 25) { sub &lt;- tibble( sub_id = 1:sub_n, sub_i = rnorm(sub_n, 0, sub_sd), sub_cond = rep(c(&quot;hard&quot;,&quot;easy&quot;), each = sub_n/2) ) stim &lt;- tibble( stim_id = 1:stim_n, stim_i = rnorm(stim_n, 0, stim_sd) ) # mean difference between easy and hard conditions sub_cond_eff &lt;- (easy_congr + easy_incon)/2 - (hard_congr + hard_incon)/2 # mean difference between incongruent and congruent versions stim_version_eff &lt;- (hard_incon + easy_incon)/2 - (hard_congr + easy_congr)/2 # interaction between version and condition cond_version_ixn &lt;- (easy_incon - easy_congr) - (hard_incon - hard_congr) dat &lt;- expand.grid( sub_id = sub$sub_id, stim_id = stim$stim_id, stim_version = c(&quot;congruent&quot;, &quot;incongruent&quot;) ) %&gt;% left_join(sub, by = &quot;sub_id&quot;) %&gt;% left_join(stim, by = &quot;stim_id&quot;) %&gt;% mutate( # effect-code subject condition and stimulus version sub_cond.e = recode(sub_cond, &quot;hard&quot; = -0.5, &quot;easy&quot; = +0.5), stim_version.e = recode(stim_version, &quot;congruent&quot; = -0.5, &quot;incongruent&quot; = +0.5), # calculate error term (normally distributed residual with SD set above) err = rnorm(nrow(.), 0, error_sd), # calculate DV from intercepts, effects, and error dv = grand_i + sub_i + stim_i + err + (sub_cond.e * sub_cond_eff) + (stim_version.e * stim_version_eff) + (sub_cond.e * stim_version.e * cond_version_ixn) ) mod &lt;- lmer(dv ~ sub_cond.e * stim_version.e + (1 | sub_id) + (1 | stim_id), data = dat) mod.sum &lt;- summary(mod) return(mod.sum) } Run the function with the default values. sim_lmer() ## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [ ## lmerModLmerTest] ## Formula: dv ~ sub_cond.e * stim_version.e + (1 | sub_id) + (1 | stim_id) ## Data: dat ## ## REML criterion at convergence: 187457 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -4.389 -0.676 -0.004 0.674 4.581 ## ## Random effects: ## Groups Name Variance Std.Dev. ## sub_id (Intercept) 8855 94.1 ## stim_id (Intercept) 2659 51.6 ## Residual 630 25.1 ## Number of obs: 20000, groups: sub_id, 200; stim_id, 50 ## ## Fixed effects: ## Estimate Std. Error df t value Pr(&gt;|t|) ## (Intercept) 390.831 9.873 140.402 39.58 &lt;2e-16 ## sub_cond.e -12.626 13.313 197.996 -0.95 0.34 ## stim_version.e 75.093 0.355 19749.001 211.61 &lt;2e-16 ## sub_cond.e:stim_version.e 50.586 0.710 19749.001 71.28 &lt;2e-16 ## ## (Intercept) *** ## sub_cond.e ## stim_version.e *** ## sub_cond.e:stim_version.e *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Correlation of Fixed Effects: ## (Intr) sb_cn. stm_v. ## sub_cond.e 0.000 ## stim_versn. 0.000 0.000 ## sb_cnd.:s_. 0.000 0.000 0.000 Try changing some variables to simulate null effects. sim_lmer(hard_congr = 0, hard_incon = 0, easy_congr = 0, easy_incon = 0) ## Warning in checkConv(attr(opt, &quot;derivs&quot;), opt$par, ctrl = ## control$checkConv, : Model failed to converge with max|grad| = 0.00336514 ## (tol = 0.002, component 1) ## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [ ## lmerModLmerTest] ## Formula: dv ~ sub_cond.e * stim_version.e + (1 | sub_id) + (1 | stim_id) ## Data: dat ## ## REML criterion at convergence: 187296 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -4.140 -0.662 -0.003 0.670 4.115 ## ## Random effects: ## Groups Name Variance Std.Dev. ## sub_id (Intercept) 11700 108.2 ## stim_id (Intercept) 2692 51.9 ## Residual 623 25.0 ## Number of obs: 20000, groups: sub_id, 200; stim_id, 50 ## ## Fixed effects: ## Estimate Std. Error df t value Pr(&gt;|t|) ## (Intercept) 407.692 10.601 165.095 38.46 &lt;2e-16 ## sub_cond.e -7.251 15.301 197.982 -0.47 0.636 ## stim_version.e -0.888 0.353 19748.994 -2.52 0.012 ## sub_cond.e:stim_version.e -0.849 0.706 19748.994 -1.20 0.229 ## ## (Intercept) *** ## sub_cond.e ## stim_version.e * ## sub_cond.e:stim_version.e ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Correlation of Fixed Effects: ## (Intr) sb_cn. stm_v. ## sub_cond.e 0.000 ## stim_versn. 0.000 0.000 ## sb_cnd.:s_. 0.000 0.000 0.000 ## convergence code: 0 ## Model failed to converge with max|grad| = 0.00336514 (tol = 0.002, component 1) 2.6 Random slopes In the example so far we've ignored random variation among subjects or stimuli in the size of the fixed effects (i.e., random slopes). First, let's reset the parameters we set above. sub_n &lt;- 200 # number of subjects in this simulation sub_sd &lt;- 100 # SD for the subjects&#39; random intercept stim_n &lt;- 50 # number of stimuli in this simulation stim_sd &lt;- 50 # SD for the stimuli&#39;s random intercept grand_i &lt;- 400 # overall mean DV sub_cond_eff &lt;- 50 # mean difference between conditions: hard - easy stim_version_eff &lt;- 50 # mean difference between versions: incongruent - congruent cond_version_ixn &lt;- 0 # interaction between version and condition error_sd &lt;- 25 # residual (error) SD 2.6.1 Subjects In addition to generating a random intercept for each subject, now we will also generate a random slope for any within-subject factors. The only within-subject factor in this design is stim_version. The main effect of stim_version is set to 50 above, but different subjects will show variation in the size of this effect. That's what the random slope captures. We'll set sub_version_sd below to the SD of this variation and use this to calculate the random slope (sub_version_slope) for each subject. Also, it's likely that the variation between subjects in the size of the effect of version is related in some way to between-subject variation in the intercept. So we want the random intercept and slope to be correlated. Here, we'll simulate a case where subjects who have slower (larger) reaction times across the board show a smaller effect of condition, so we set sub_i_version_cor below to a negative number (-0.2). I'm writing a package that has functions to easily create correlated variables for simulations. The function rnorm_multi generates n observations of vars variables with mu means and sd standard deviations with cors specific correlations. You can learn more about this function at my Simulating Multiple Vectors tutorial. You can use devtools::install_github(&quot;debruine/faux&quot;) to install the package. The code below creates two variables (sub_i, sub_version_slope) that are correlated with r = -0.2, means of 0, and SDs equal to what we set sub_sd above and sub_version_sd below. sub_version_sd &lt;- 20 sub_i_version_cor &lt;- -0.2 sub &lt;- rnorm_multi( n = sub_n, vars = 2, cors = sub_i_version_cor, mu = 0, # means of random intercepts and slopes are always 0 sd = c(sub_sd, sub_version_sd), varnames = c(&quot;sub_i&quot;, &quot;sub_version_slope&quot;) ) %&gt;% mutate( sub_id = 1:sub_n, sub_cond = rep(c(&quot;easy&quot;,&quot;hard&quot;), each = sub_n/2) # between-subjects factor ) Plot to double-check it looks sensible. ggplot(sub, aes(sub_i, sub_version_slope, color = sub_cond)) + geom_point() + geom_smooth(method = lm) Figure 2.7: Double-check slope-intercept correlations 2.6.2 Stimuli In addition to generating a random intercept for each stimulus, we will also generate a random slope for any within-stimulus factors. Both stim_version and sub_condition are within-stimulus factors (i.e., all stimuli are seen in both congruent and incongruent versions and both easy and hard conditions). So the main effects of version and condition (and their interaction) will vary depending on the stimulus. They will also be correlated, but in a more complex way than above. You need to set the correlations for all pairs of slopes and intercept. Let's set the correlation between the random intercept and each of the slopes to -0.4 and the slopes all correlate with each other +0.2 (You could set each of the six correlations separately if you want, though). See the Simulating Multiple Vectors tutorial for other ways to set the correlations. stim_version_sd &lt;- 10 # SD for the stimuli&#39;s random slope for stim_version stim_cond_sd &lt;- 30 # SD for the stimuli&#39;s random slope for sub_cond stim_cond_version_sd &lt;- 15 # SD for the stimuli&#39;s random slope for sub_cond:stim_version stim_i_cor &lt;- -0.4 # correlations between intercept and slopes stim_s_cor &lt;- +0.2 # correlations among slopes # specify correlations for rnorm_multi (one of several methods) stim_cors &lt;- c(stim_i_cor, stim_i_cor, stim_i_cor, stim_s_cor, stim_s_cor, stim_s_cor) stim &lt;- rnorm_multi( n = stim_n, vars = 4, cors = stim_cors, mu = 0, # means of random intercepts and slopes are always 0 sd = c(stim_sd, stim_version_sd, stim_cond_sd, stim_cond_version_sd), varnames = c(&quot;stim_i&quot;, &quot;stim_version_slope&quot;, &quot;stim_cond_slope&quot;, &quot;stim_cond_version_slope&quot;) ) %&gt;% mutate( stim_id = 1:stim_n ) Here, we're simulating different SDs for different effects, so our plot should reflect this. The graph below uses the `ggpairs function fromt he GGally package to quickly visualise correlated variables. GGally::ggpairs(stim, columns = 1:4, lower = list(continuous = &quot;smooth&quot;), progress = FALSE) Figure 2.8: Double-check slope-intercept correlations 2.6.3 Trials Now we put the subjects and stimuli together in the same way as before. trials &lt;- expand.grid( sub_id = sub$sub_id, # get subject IDs from the sub data table stim_id = stim$stim_id, # get stimulus IDs from the stim data table stim_version = c(&quot;congruent&quot;, &quot;incongruent&quot;) # all subjects see both congruent and incongruent versions of all stimuli ) %&gt;% left_join(sub, by = &quot;sub_id&quot;) %&gt;% # includes the intercept, slope, and conditin for each subject left_join(stim, by = &quot;stim_id&quot;) # includes the intercept and slopes for each stimulus Table 2.4: Subject- and stimulus-specific random intercepts and slopes for 2 subjects and 2 stimuli sub_id stim_id stim_version sub_i sub_version_slope sub_cond stim_i stim_version_slope stim_cond_slope stim_cond_version_slope 1 1 congruent -63.15 -23.61 easy 11.54 -0.0276 28.62 7.068 2 1 congruent 98.23 -2.32 easy 11.54 -0.0276 28.62 7.068 1 2 congruent -63.15 -23.61 easy -14.00 1.4777 -26.67 -1.602 2 2 congruent 98.23 -2.32 easy -14.00 1.4777 -26.67 -1.602 1 1 incongruent -63.15 -23.61 easy 11.54 -0.0276 28.62 7.068 2 1 incongruent 98.23 -2.32 easy 11.54 -0.0276 28.62 7.068 1 2 incongruent -63.15 -23.61 easy -14.00 1.4777 -26.67 -1.602 2 2 incongruent 98.23 -2.32 easy -14.00 1.4777 -26.67 -1.602 2.7 Calculate DV Now we can calculate the DV by adding together an overall intercept (mean RT for all trials), the subject-specific intercept, the stimulus-specific intercept, the effect of subject condition, the stimulus-specific slope for condition, the effect of stimulus version, the stimulus-specific slope for version, the subject-specific slope for condition, the interaction between condition and version (set to 0 for this example), the stimulus-specific slope for the interaction between condition and version, and an error term. dat &lt;- trials %&gt;% mutate( # effect-code subject condition and stimulus version sub_cond.e = recode(sub_cond, &quot;hard&quot; = -0.5, &quot;easy&quot; = +0.5), stim_version.e = recode(stim_version, &quot;congruent&quot; = -0.5, &quot;incongruent&quot; = +0.5), # calculate trial-specific effects by adding overall effects and slopes cond_eff = sub_cond_eff + stim_cond_slope, version_eff = stim_version_eff + stim_version_slope + sub_version_slope, cond_version_eff = cond_version_ixn + stim_cond_version_slope, # calculate error term (normally distributed residual with SD set above) err = rnorm(nrow(.), 0, error_sd), # calculate DV from intercepts, effects, and error dv = grand_i + sub_i + stim_i + err + (sub_cond.e * cond_eff) + (stim_version.e * version_eff) + (sub_cond.e * stim_version.e * cond_version_eff) ) As always, graph to make sure you've simulated the general pattern you expected. ggplot(dat, aes(sub_cond, dv, color = stim_version)) + geom_hline(yintercept = grand_i) + geom_violin(alpha = 0.5) + geom_boxplot(width = 0.2, position = position_dodge(width = 0.9)) Figure 2.9: Double-check the simulated pattern 2.8 Analysis New we'll run a linear mixed effects model with lmer and look at the summary. You specify random slopes by adding the within-level effects to the random intercept specifications. Since the only within-subject factor is version, the random effects specification for subjects is (1 + stim_version.e | sub_id). Since both condition and version are within-stimuli factors, the random effects specification for stimuli is (1 + stim_version.e*sub_cond.e | stim_id). Keep It Maximal is a great paper on how and why to set random slopes maximally like this. This model will take a lot longer to run than one without random slopes specified. mod &lt;- lmer(dv ~ sub_cond.e * stim_version.e + (1 + stim_version.e | sub_id) + (1 + stim_version.e*sub_cond.e | stim_id), data = dat) ## Warning in checkConv(attr(opt, &quot;derivs&quot;), opt$par, ctrl = ## control$checkConv, : Model failed to converge with max|grad| = 0.0132569 ## (tol = 0.002, component 1) mod.sum &lt;- summary(mod) mod.sum ## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [ ## lmerModLmerTest] ## Formula: ## dv ~ sub_cond.e * stim_version.e + (1 + stim_version.e | sub_id) + ## (1 + stim_version.e * sub_cond.e | stim_id) ## Data: dat ## ## REML criterion at convergence: 188357 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -4.799 -0.661 -0.007 0.657 3.788 ## ## Random effects: ## Groups Name Variance Std.Dev. Corr ## sub_id (Intercept) 9842.1 99.21 ## stim_version.e 317.3 17.81 -0.07 ## stim_id (Intercept) 2485.4 49.85 ## stim_version.e 93.5 9.67 -0.56 ## sub_cond.e 646.6 25.43 -0.25 0.08 ## stim_version.e:sub_cond.e 269.3 16.41 -0.39 0.32 0.58 ## Residual 627.3 25.05 ## Number of obs: 20000, groups: sub_id, 200; stim_id, 50 ## ## Fixed effects: ## Estimate Std. Error df t value Pr(&gt;|t|) ## (Intercept) 406.39 9.95 156.06 40.85 &lt; 2e-16 *** ## sub_cond.e 61.29 14.49 220.86 4.23 0.000034 *** ## stim_version.e 49.29 1.89 133.47 26.04 &lt; 2e-16 *** ## sub_cond.e:stim_version.e -2.04 3.50 158.43 -0.58 0.56 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Correlation of Fixed Effects: ## (Intr) sb_cn. stm_v. ## sub_cond.e -0.044 ## stim_versn. -0.322 0.014 ## sb_cnd.:s_. -0.181 0.045 0.155 ## convergence code: 0 ## Model failed to converge with max|grad| = 0.0132569 (tol = 0.002, component 1) 2.8.1 Sense checks First, check that your groups make sense (mod.sum$ngrps). sub_id = sub_n (200) stim_id = stim_n (50) ## sub_id stim_id ## 200 50 Next, look at the SDs for the random effects (mod.sum$varcor). Group:sub_id (Intercept) ~= sub_sd (100) stim_version.e ~= sub_version_sd (20) Group: stim_id (Intercept) ~= stim_sd (50) stim_version.e ~= stim_version_sd (10) sub_cond.e ~= stim_cond_sd (30) stim_version.e:sub_cond.e ~= stim_cond_version_sd (15) Residual ~= error_sd (25) ## Groups Name Std.Dev. Corr ## sub_id (Intercept) 99.21 ## stim_version.e 17.81 -0.07 ## stim_id (Intercept) 49.85 ## stim_version.e 9.67 -0.56 ## sub_cond.e 25.43 -0.25 0.08 ## stim_version.e:sub_cond.e 16.41 -0.39 0.32 0.58 ## Residual 25.05 The correlations are a bit more difficult to parse. The first column under Corr shows the correlation between the random slope for that row and the random intercept. So for stim_version.e under sub_id, the correlation should be close to sub_i_version_cor (-0.2). For all three random slopes under stim_id, the correlation with the random intercept should be near stim_i_cor (-0.4) and their correlations with each other should be near stim_s_cor (0.2). ## Groups Name Std.Dev. Corr ## sub_id (Intercept) 99.21 ## stim_version.e 17.81 -0.07 ## stim_id (Intercept) 49.85 ## stim_version.e 9.67 -0.56 ## sub_cond.e 25.43 -0.25 0.08 ## stim_version.e:sub_cond.e 16.41 -0.39 0.32 0.58 ## Residual 25.05 Finally, look at the fixed effects (mod.sum$coefficients). (Intercept) ~= grand_i (400) sub_cond.e ~= sub_cond_eff (50) stim_version.e ~= stim_version_eff (50) sub_cond.e:stim_version.e ~= cond_version_ixn (0) ## Estimate Std. Error df t value Pr(&gt;|t|) ## (Intercept) 406.393 9.947 156.1 40.854 3.083e-85 ## sub_cond.e 61.291 14.488 220.9 4.231 3.417e-05 ## stim_version.e 49.289 1.893 133.5 26.039 3.660e-54 ## sub_cond.e:stim_version.e -2.043 3.498 158.4 -0.584 5.600e-01 2.8.2 Random effects Plot the subject intercepts and slopes from our code above (sub$sub_i) against the subject intercepts and slopes calculcated by lmer (ranef(mod)$sub_id). ranef(mod)$sub_id %&gt;% as_tibble(rownames = &quot;sub_id&quot;) %&gt;% rename(mod_i = `(Intercept)`, mod_version_slope = stim_version.e) %&gt;% mutate(sub_id = as.integer(sub_id)) %&gt;% left_join(sub, by = &quot;sub_id&quot;) %&gt;% select(mod_i, sub_i, mod_version_slope, sub_version_slope) %&gt;% GGally::ggpairs(lower = list(continuous = &quot;smooth&quot;), progress = FALSE) Figure 2.10: Compare simulated subject random effects to those from the model Plot the stimulus intercepts and slopes from our code above (stim$stim_i) against the stimulus intercepts and slopes calculcated by lmer (ranef(mod)$stim_id). ranef(mod)$stim_id %&gt;% as_tibble(rownames = &quot;stim_id&quot;) %&gt;% rename(mod_i = `(Intercept)`, mod_version_slope = stim_version.e, mod_cond_slope = sub_cond.e, mod_cond_version_slope = `stim_version.e:sub_cond.e`) %&gt;% mutate(stim_id = as.integer(stim_id)) %&gt;% left_join(stim, by = &quot;stim_id&quot;) %&gt;% select(mod_i, stim_i, mod_version_slope, stim_version_slope, mod_cond_slope, stim_cond_slope, mod_cond_version_slope, stim_cond_version_slope) %&gt;% GGally::ggpairs(lower = list(continuous = &quot;smooth&quot;), progress = FALSE) Figure 2.11: Compare simulated stimulus random effects to those from the model 2.9 Function You can put the code above in a function so you can run it more easily and change the parameters. I removed the plot and set the argument defaults to the same as the example above, but you can set them to other patterns. sim_lmer &lt;- function( sub_n = 200, sub_sd = 100, sub_version_sd = 20, sub_i_version_cor = -0.2, stim_n = 50, stim_sd = 50, stim_version_sd = 10, stim_cond_sd = 30, stim_cond_version_sd = 15, stim_i_cor = -0.4, stim_s_cor = +0.2, grand_i = 400, hard_congr = -25, hard_incon = +25, easy_congr = -50, easy_incon = +50, error_sd = 25) { sub &lt;- rnorm_multi( n = sub_n, vars = 2, cors = sub_i_version_cor, mu = 0, # means of random intercepts and slopes are always 0 sd = c(sub_sd, sub_version_sd), varnames = c(&quot;sub_i&quot;, &quot;sub_version_slope&quot;) ) %&gt;% mutate( sub_id = 1:sub_n, sub_cond = rep(c(&quot;easy&quot;,&quot;hard&quot;), each = sub_n/2) # between-subjects factor ) stim_cors &lt;- c(stim_i_cor, stim_i_cor, stim_i_cor, stim_s_cor, stim_s_cor, stim_s_cor) stim &lt;- rnorm_multi( n = stim_n, vars = 4, cors = stim_cors, mu = 0, # means of random intercepts and slopes are always 0 sd = c(stim_sd, stim_version_sd, stim_cond_sd, stim_cond_version_sd), varnames = c(&quot;stim_i&quot;, &quot;stim_version_slope&quot;, &quot;stim_cond_slope&quot;, &quot;stim_cond_version_slope&quot;) ) %&gt;% mutate( stim_id = 1:stim_n ) # mean difference between easy and hard conditions sub_cond_eff &lt;- (easy_congr + easy_incon)/2 - (hard_congr + hard_incon)/2 # mean difference between incongruent and congruent versions stim_version_eff &lt;- (hard_incon + easy_incon)/2 - (hard_congr + easy_congr)/2 # interaction between version and condition cond_version_ixn &lt;- (easy_incon - easy_congr) - (hard_incon - hard_congr) trials &lt;- expand.grid( sub_id = sub$sub_id, # get subject IDs from the sub data table stim_id = stim$stim_id, # get stimulus IDs from the stim data table stim_version = c(&quot;congruent&quot;, &quot;incongruent&quot;) # all subjects see both congruent and incongruent versions of all stimuli ) %&gt;% left_join(sub, by = &quot;sub_id&quot;) %&gt;% # includes the intercept, slope, and conditin for each subject left_join(stim, by = &quot;stim_id&quot;) # includes the intercept and slopes for each stimulus dat &lt;- trials %&gt;% mutate( # effect-code subject condition and stimulus version sub_cond.e = recode(sub_cond, &quot;hard&quot; = -0.5, &quot;easy&quot; = +0.5), stim_version.e = recode(stim_version, &quot;congruent&quot; = -0.5, &quot;incongruent&quot; = +0.5), # calculate trial-specific effects by adding overall effects and slopes cond_eff = sub_cond_eff + stim_cond_slope, version_eff = stim_version_eff + stim_version_slope + sub_version_slope, cond_version_eff = cond_version_ixn + stim_cond_version_slope, # calculate error term (normally distributed residual with SD set above) err = rnorm(nrow(.), 0, error_sd), # calculate DV from intercepts, effects, and error dv = grand_i + sub_i + stim_i + err + (sub_cond.e * cond_eff) + (stim_version.e * version_eff) + (sub_cond.e * stim_version.e * cond_version_eff) ) mod &lt;- lmer(dv ~ sub_cond.e * stim_version.e + (1 + stim_version.e | sub_id) + (1 + stim_version.e*sub_cond.e | stim_id), data = dat) mod.sum &lt;- summary(mod) return(mod.sum) } Run the function with the default values. sim_lmer() Try changing some variables to simulate null effects. sim_lmer(hard_congr = 0, hard_incon = 0, easy_congr = 0, easy_incon = 0) "],
["webpages.html", "Chapter 3 Webpages 3.1 Learning objectives 3.2 Create a webpage 3.3 Add content 3.4 Add pages 3.5 Styles 3.5.4 Example using the styles above 3.6 Put your webpage online", " Chapter 3 Webpages 3.1 Learning objectives Create a simple webpage using R Markdown Use version control with your files Create content in R Markdown Link multiple pages Style your content using css Host your website on GitHub or GitLab 3.2 Create a webpage 3.2.1 Create a project Choose New Project... from the File menu (don't save any workspaces) Choose the Version Control option If you don't have this option, set up git using the instructions in Appendix @ref(#setup-git). Choose the Git option to clone a project from a git repository Set the Repository URL This will look something like ssh://git@github.com/USERNAME/mywebpage.git or git@gitlab.com:USERNAME/mywebpage.git. Make sure to replace USERNAME with your GitHub or GitLab username and mywebpage with the name of your project if you didn't use that name. Type in your SSH passphrase 3.2.2 Site header This is where you can set options like whether to show a table of contents and what the navigation bar will look like. We'll edit this later to add a section menu. Make a new file Choose New File &gt; Text File from the File menu Put the following text in the file: name: &quot;mywebpage&quot; author: &quot;YOUR NAME&quot; output_dir: &quot;docs&quot; output: html_document: self_contained: no theme: flatly navbar: title: &quot;My First Webpage&quot; Save the file as _site.yml (do not change the name) 3.2.3 Site script (only for GitLab) This file contains instructions for copying files from your private GitLab repository to the public web resources. You don't need it for a GitHub website because all the files are public. Make a new file Choose New File &gt; Text File from the File menu Put the following text in the file: pages: stage: deploy script: - mkdir .public - cp -r docs/* .public - mv .public public artifacts: paths: - public only: - master Save the file as .gitlab-ci.yml (do not change the name) 3.2.4 Main page Make a new file Choose New File &gt; R Markdown... from the File menu Replace all of the default text with the following text: --- title: &quot;My Website Name&quot; --- I am a postgraduate student in the University of Glasgow&#39;s [Institute of Neuroscience and Psychology](http://www.gla.ac.uk/researchinstitutes/neurosciencepsychology/). I work with [Supervisor&#39;s Name](http://supervisor/website) Personalise the website name, supervisor name, and supervisor website link. Save the file as index.Rmd (do not change the name) 3.2.5 Render the site Type rmarkdown::render_site() into the lower left Console pane. You might get some error messages about the graphics engine. You can ignore those for now. Click on the docs directory in the Files tab of the lower right pane Click on index.html and choose View in Web Browser Check if your links work, edit and repeat if they don't 3.3 Add content If you are comfortable with HTML, you can write most of your page in HTML. If not, I'd suggest using rmarkdown, whcih is a simple way to indicate headings, paragraphs, links, lists and images. 3.3.1 Headings and paragraphs Headings are prefaces with hashes #. The largest, title heading gets one hash and each subheading level adds another hash. Paragraphs don't require any special marks, they are just automatically created when you skip a line between blocks of text. ### Headings and paragraphs Headings are prefaces with hashes `#`. The largest, title heading gets one hash and each subheading level adds another hash. Paragraphs don&#39;t require any special marks, they are just automatically created when you skip a line between blocks of text. 3.3.2 Links Links are just text surrounded by square brackets, followed by the URL surrounded by parentheses. Start the URL with http:// if it's an external website. If you want to link to one of your own pages, you can just put the name of the page. I can link to Google or to my own main page. I can link to [Google](http://google.com) or to [my own main page](index.html). 3.3.3 Lists You can make bullet point lists by prefacing items with * or numeric lists by prefacing them with numbers. Make nested lists by indenting 4 spaces. Face Research Lab: Permanent Staff Lisa Ben Postdocs Iris Ant Kieran PhD Students Danielle Chengyang Vanessa Jaimie Things I need to do: Finish this lesson Write new R script for hormones project Write reference letter Check Moodle Face Research Lab: * Permanent Staff * Lisa * Ben * Postdocs * Iris * Ant * Kieran * PhD Students * Danielle * Chengyang * Vanessa * Jaimie Things I need to do: 1. Finish this lesson 1. Write new R script for hormones project 1. Write reference letter 1. Check Moodle Notice how the numeric list uses all number 1. You can use incrementing numbers if you want, but using all 1s makes it easier to change the order of your items with out having the renumber. 3.3.4 Images Images are created much like links. Just put an exclamation mark (!) before the first brasket and put some explanatory text (title and image credit) in the squre brackets, and the image location in the parentheses. A pangolin, by Bart Wursten ![A pangolin, by Bart Wursten](images/pangolin.jpg) 3.4 Add pages Create a new .Rmd file for each webpage Add content to the webpages (more on this below) Type rmarkdown::render_site() in the Console window 3.5 Styles 3.5.1 Change the theme The _site.yml file theme option specifies the Bootstrap theme to use for the page. You can use default, cerulean, journal, flatly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, and yeti. Annoyingly, there are no dark themes available by default. name: &quot;mywebpage&quot; author: &quot;YOUR NAME&quot; output_dir: &quot;docs&quot; output: html_document: self_contained: no theme: flatly css: style.css navbar: title: &quot;My First Webpage&quot; 3.5.2 Add custom styles You can also add a custom style sheet (a document that determines how each element of your website should look) by adding the line css: style.css under html_document: in the _site.yml file (as above). Then you need to create a file named style.css and add your custom styles there. The web has thousands of guides to CSS, but codeacademy has great interactive tutorials for learning html, css, and even more advanced web coding like javascript. However, the basics of css are easy to learn and it's best to just start playing around with it. Add the following text to your style.css file and re-render the website using rmarkdown::render_site(). 3.5.3 Change global fonts and colours html { font-size: 2em; font-family: &quot;Times New Roman&quot;; color: white; background-color: hsl(360, 100%, 20%); } #html-example * { font-size: 2em; font-family: \"Times New Roman\"; color: white; background-color: hsl(300, 100%, 20%); } This will make all the text on your website twice as large, a different font, and change the text and background colours. 3.5.4 Change certain elements Maybe you only want to change the font colour for your headings, not the rest of the text. You can apply a style to a specific element type by specifying the element name before the curly brackets. h1, h2, h3 { text-align: center; color: hsl(0, 100%, 20%); } h3 { font-style: italic; } p { border: 1px solid green; padding: 10px; line-height: 2; } ul { border: 3px dotted red; border-radius: 10px; padding: 10px 30px; } #h-example h2, #h-example h3, #h-example h4 { text-align: center; color: hsl(0, 100%, 20%); } #h-example h4 { font-style: italic; } #h-example p { border: 1px solid green; padding: 10px; line-height: 2; } #h-example ul { border: 3px dotted red; border-radius: 10px; padding: 10px 30px; } 3.5.4 Example using the styles above The CSS above changes the styles for three levels of headers (h2, h3, h4) and sets the third level to italics. 3.5.4 Level 3 header It also gives paragraphs (p) a green border and double-spacing. 3.5.4 Level 4 header Unordered Lists (ul) get: dotted red border round corners increased padding on top (10px) and sides (30px) 3.6 Put your webpage online 3.6.1 Save this version with git Click on the git tab in the upper right pane Stage your files Select all (cmd-A) and click on a checkbox in the Staged column to select all files Commit your changes Click Commit. A new window will open. Type Added site and index pages in the Commit message box and click Commit Close the progress window and the commit window Upload your changes Click Push (the green up arrow) Enter your SSH passphrase Close the window when it's done Go to your GitHub or GitLab page; the new files should be in your repository 3.6.2 GitHub To use a GitHub repository as a website, you need to set the source directory the first time you add files to the docs directory. Go to the website for your GitHub repository (e.g., https://github.com/username/mywebpage) Click on the Settings tab and scroll down to GitHub Pages Under Source, choose master branch /docs folder and click Save Click on the link that appears above (e.g., https://debruine.github.io/mywebpage/) 3.6.3 GitLab If you are working in GitLab, your webpage should be created in a minute or two. Just go to the URL like https://myusername.gitlab.io/mywebpage/. "],
["installing-r.html", "A Installing R A.1 Installing Base R A.2 Installing RStudio A.3 Installing LaTeX", " A Installing R Installing R and RStudio is usually straightforward. The sections below explain how and there is a helpful YouTube video here. A.1 Installing Base R Install base R from https://cran.rstudio.com/. Choose the download link for your operating system (Linux, Mac OS X, or Windows). If you have a Mac, install the latest release from the newest R-x.x.x.pkg link (or a legacy version if you have an older operating system). After you install R, you should also install XQuartz to be able to use some visualisation packages. If you are installing the Windows version, choose the &quot;base&quot; subdirectory and click on the download link at the top of the page. After you install R, you should also install RTools; use the &quot;recommended&quot; version highlighted near the top of the list. If you are using Linux, choose your specific operating system and follow the installation instructions. A.2 Installing RStudio Go to rstudio.com and download the RStudio Desktop (Open Source License) version for your operating system under the list titled Installers for Supported Platforms. A.3 Installing LaTeX You can install the LaTeX typesetting system to produce PDF reports from RStudio. Without this additional installation, you will be able to produce reports in HTML but not PDF. To generate PDF reports, you will additionally need: pandoc, and LaTeX, a typesetting language, available for WINDOWS: MikTeX Mac OS: MacTex (3.2GB download) or BasicTeX (78MB download, but should work fine) Linux: TeX Live "],
["setup-git.html", "B Git and GitHub B.1 Get a GitHub account B.2 Set up RStudio B.3 Set your GitHub info B.4 Create an SSH Key on RStudio B.5 Create an SSH Key on GitHub", " B Git and GitHub There are many reasons to use version control. Git is one option and it is well-integrated into RStudio. GitHub is a free service to store your version controlled projects in the cloud and (optionally) share them with others. B.1 Get a GitHub account Go to GitHub and create a new account. Make sure your username is professional Use an email address that you won't lose access to (e.g., gmail) B.2 Set up RStudio If you are a UofG INP staff/student, you can access the Glasgow Psychology RStudio site and skip to Set your GitHub info. If you are working from your own computer, follow the next 2 sub-steps: B.2.1 Install git You can check if git is already installed on your computer by going to Shell... under the Tools menu (or just open a terminal window) and typing which git. If you get an answer like /usr/local/bin/git then git is already installed. If not, install git and then use which git to check where it is installed. B.2.2 Enable version control in RStudio Go to Global Options... from the Tools menu and set the location of your git executable to the location from the previous step. Figure B.1: Set the location of git B.3 Set your GitHub info Run usethis::edit_git_config() in the console pane; it will open a file called .gitconfig. Replace GITHUB_EMAIL with the email address you used for github and GITHUB_USERNAME with your github username. [user] email = GITHUB_EMAIL name = GITHUB_USERNAME You can skip the rest of the steps if you are using your own computer because you can use https to access github. If you are using an RStudio server or just want to use SSH, follow the steps below. B.4 Create an SSH Key on RStudio Go to Global Options... from the Tools menu Click Create RSA Key... and enter a passphrase Figure B.2: Global options Click on View public key and copy the contents of the box B.5 Create an SSH Key on GitHub Go to GitHub &gt; Settings &gt; SSH and GPG keys Click New SSH Key Put RStudio server as the title (or My Computer Name if on your own computer) Paste your public key into the Key box Click Add SSH key Figure B.3: Add SSH key "],
["pipes.html", "C Pipes", " C Pipes Pipes are a way to order your code in a more readable format. Let's say you have a small data table with 10 participant IDs, two columns with variable type A, and 2 columns with variable type B. You want to calculate the mean of the A variables and the mean of the B variables and return a table with 10 rows (1 for each participant) and 3 columns (id, A_mean and B_mean). One way you could do this is by creating a new object at every step and using that object in the next step. This is pretty clear, but you've created 6 unnecessary data objects in your environment. This can get confusing in very long scripts. library(tidyverse) # make a data table with 10 subjects data_original &lt;- tibble( id = 1:10, A1 = rnorm(10, 0), A2 = rnorm(10, 1), B1 = rnorm(10, 2), B2 = rnorm(10, 3) ) # gather columns A1 to B2 into &quot;variable&quot; and &quot;value&quot; columns data_gathered &lt;- gather(data_original, variable, value, A1:B2) # separate the variable column at the _ into &quot;var&quot; and &quot;var_n&quot; columns data_separated &lt;- separate(data_gathered, variable, c(&quot;var&quot;, &quot;var_n&quot;), sep = 1) # group the data by id and var data_grouped &lt;- group_by(data_separated, id, var) # calculate the mean value for each id/var data_summarised &lt;- summarise(data_grouped, mean = mean(value)) # spread the mean column into A and B columns data_spread &lt;- spread(data_summarised, var, mean) # rename A and B to A_mean and B_mean data &lt;- rename(data_spread, A_mean = A, B_mean = B) id A_mean B_mean 1 0.7834151 2.221239 2 0.0727862 2.052466 3 1.0975524 2.802452 4 1.6159707 1.459485 5 0.6841141 3.345551 6 1.1469719 1.857865 7 -0.2070695 1.996193 8 0.6342169 1.890787 9 -0.4276909 2.104264 10 0.4651093 2.527036 You can name each object data and keep replacing the old data object with the new one at each step. This will keep you environment clean, but I don't recommend it because it makes it too easy to accidentally run your code out of order when you are running line-by-line for development or debugging. One way to avoid extra objects is to nest your functions, literally replacing each data object with the code that generated it in the previous step. This can be fine for very short chains. mean_petal_width &lt;- round(mean(iris$Petal.Width), 2) But it gets extremely confusing for long chains: # do not ever do this!! data &lt;- rename( spread( summarise( group_by( separate( gather( tibble( id = 1:10, A1 = rnorm(10, 0), A2 = rnorm(10, 1), B1 = rnorm(10, 2), B2 = rnorm(10, 3)), variable, value, A1:B2), variable, c(&quot;var&quot;, &quot;var_n&quot;), sep = 1), id, var), mean = mean(value)), var, mean), A_mean = A, B_mean = B) The pipe lets you &quot;pipe&quot; the result of each function into the next function, allowing you to put your code in a logical order without creating too many extra objects. # calculate mean of A and B variables for each participant data &lt;- tibble( id = 1:10, A1 = rnorm(10, 0), A2 = rnorm(10, 1), B1 = rnorm(10, 2), B2 = rnorm(10, 3) ) %&gt;% gather(variable, value, A1:B2) %&gt;% separate(variable, c(&quot;var&quot;, &quot;var_n&quot;), sep=1) %&gt;% group_by(id, var) %&gt;% summarise(mean = mean(value)) %&gt;% spread(var, mean) %&gt;% rename(A_mean = A, B_mean = B) You can read this code from top to bottom as follows: Make a tibble called data with id of 1 to 10, A1 of 10 random numbers from a normal distribution with a mean of 0, A2 of 10 random numbers from a normal distribution with a mean of 1, B1 of 10 random numbers from a normal distribution with a mean of 2, B2 of 10 random numbers from a normal distribution with a mean of 3; and then Gather to create variable and value column from columns A_1 to B_2; and then Separate the column variable into 2 new columns called varand var_n, separate at character 1; and then Group by columns id and var; and then Summarise and new column called mean as the mean of the value column for each group; and then Spread to make new columns with the key names in var and values in mean; and then Rename to make columns called A_mean (old A) and B_mean (old B) You can make intermediate objects whenever you need to break up your code because it's getting too complicated or you need to debug something. You can debug a pipe by running just the first few functions by highlighting from the beginning to just before the pipe you want to stop at. Try this by highlighting from data &lt;- to the end of the separate function and typing cmd-return. What does data look like now? "],
["symbols.html", "D Symbols", " D Symbols Symbol psyTeachR Term Also Known As () (round) brackets parentheses [] square brackets brackets {} curly brackets squiggly brackets &lt;&gt; chevrons angled brackets / guillemets &lt; less than &gt; greater than &amp; ampersand &quot;and&quot; symbol # hash pound / octothorpe / slash forward slash \\ backslash - dash hyphen / minus _ underscore * asterisk star ^ caret power symbol ~ tilde twiddle / squiggle = equal sign == double equal sign . full stop period / point ! exclamation mark bang / not ? question mark ' single quote quote / apostrophe &quot; double quote quote %&gt;% pipe magrittr pipe | vertical bar pipe , comma ; semi-colon : colon @ &quot;at&quot; symbol various hilarious regional terms "]
]
